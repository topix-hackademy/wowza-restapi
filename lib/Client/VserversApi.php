<?php
/**
 * VserversApi
 * PHP version 5
 *
 * @category Class
 * @package  WowzaApi
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Topix\Hackademy\WowzaApi\Client;

use Topix\Hackademy\WowzaApi\Configuration;
use Topix\Hackademy\WowzaApi\ApiClient;
use Topix\Hackademy\WowzaApi\ApiException;
use Topix\Hackademy\WowzaApi\Model\ServerConfig;
use Topix\Hackademy\WowzaApi\Model\ServerConfigAdv;
use Topix\Hackademy\WowzaApi\Model\ServerLogFileConfig;
use Topix\Hackademy\WowzaApi\Model\ServerLogFileDownloadConfig;
use Topix\Hackademy\WowzaApi\Model\ServerLogFilesConfig;
use Topix\Hackademy\WowzaApi\Model\ServerLogsConfig;
use Topix\Hackademy\WowzaApi\Model\ServerLogTypesConfig;
use Topix\Hackademy\WowzaApi\Model\ServersConfig;
use Topix\Hackademy\WowzaApi\Model\SourceDriverNamesList;
use Topix\Hackademy\WowzaApi\ObjectSerializer;

/**
 * VserversApi Class Doc Comment
 *
 * @category Class
 * @package  WowzaApi
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class VserversApi extends SwaggerApi
{



    /**
     * Operation getServerConfig
     *
     * Retrieves the Server configuration.
     *
     * @param string $serverName Reserved for future use (required)
     *
     * @return  ServerConfig
     * @throws ApiException on non-2xx response
     */
    public function getServerConfig($serverName)
    {
        list($response) = $this->getServerConfigWithHttpInfo($serverName);
        return $response;
    }


    /**
     * Operation getServerConfigWithHttpInfo
     *
     * Retrieves the Server configuration.
     *
     * @param string $serverName Reserved for future use (required)
     *
     * @return Array of \Model\ServerConfig, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function getServerConfigWithHttpInfo($serverName)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling getServerConfig');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                ServerConfig::class
            );
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array($this->apiClient->getSerializer()->deserialize($response, ServerConfig::class, $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), ServerConfig::class, $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
    /**
     * Operation getServerConfigAdv
     *
     * Retrieves the advanced Server configuration.
     *
     * @param string $serverName Reserved for future use (required)
     *
     * @return  ServerConfigAdv
     * @throws ApiException on non-2xx response
     */
    public function getServerConfigAdv($serverName)
    {
        list($response) = $this->getServerConfigAdvWithHttpInfo($serverName);
        return $response;
    }


    /**
     * Operation getServerConfigAdvWithHttpInfo
     *
     * Retrieves the advanced Server configuration.
     *
     * @param string $serverName Reserved for future use (required)
     *
     * @return Array of \Model\ServerConfigAdv, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function getServerConfigAdvWithHttpInfo($serverName)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling getServerConfigAdv');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}/adv";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                ServerConfigAdv::class
            );
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array($this->apiClient->getSerializer()->deserialize($response, ServerConfigAdv::class, $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), ServerConfigAdv::class, $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
    /**
     * Operation getServerLogFileConfig
     *
     * Retrieves the contents of a Server Log with the specified log name.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $logName The name of the log (required)
     * @param string $lineCount The number of log lines requested, where a postive number indicates log lines after startOffset and a negative number indicate log lines before startOffset (optional, default to 100)
     * @param string $startOffset The byte offset in the file at which to begin getting log lines (optional)
     * @param string $filter A string containing a list of predefined search filters separated by | where valid strings are noDebug,noInfo,noWarn,noError,noHeader,noColumnHeadings (optional)
     * @param string $search A string containing a literal string on which to filter or a regex (optional)
     * @param string $regexSearch Indicates if the &#39;search&#39; parameter is a regex or a literal string (optional, default to false)
     * @param string $head Returns the first x lines from the requested log file, the overrides the startoffset and linecount values (optional)
     * @param string $tail Returns the last x lines from the requested log file, the overrides the startoffset and linecount values (optional)
     *
     * @return  ServerLogFileConfig
     * @throws ApiException on non-2xx response
     */
    public function getServerLogFileConfig($serverName, $logName, $lineCount = null, $startOffset = null, $filter = null, $search = null, $regexSearch = null, $head = null, $tail = null)
    {
        list($response) = $this->getServerLogFileConfigWithHttpInfo($serverName, $logName, $lineCount, $startOffset, $filter, $search, $regexSearch, $head, $tail);
        return $response;
    }


    /**
     * Operation getServerLogFileConfigWithHttpInfo
     *
     * Retrieves the contents of a Server Log with the specified log name.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $logName The name of the log (required)
     * @param string $lineCount The number of log lines requested, where a postive number indicates log lines after startOffset and a negative number indicate log lines before startOffset (optional, default to 100)
     * @param string $startOffset The byte offset in the file at which to begin getting log lines (optional)
     * @param string $filter A string containing a list of predefined search filters separated by | where valid strings are noDebug,noInfo,noWarn,noError,noHeader,noColumnHeadings (optional)
     * @param string $search A string containing a literal string on which to filter or a regex (optional)
     * @param string $regexSearch Indicates if the &#39;search&#39; parameter is a regex or a literal string (optional, default to false)
     * @param string $head Returns the first x lines from the requested log file, the overrides the startoffset and linecount values (optional)
     * @param string $tail Returns the last x lines from the requested log file, the overrides the startoffset and linecount values (optional)
     *
     * @return Array of \Model\ServerLogFileConfig, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function getServerLogFileConfigWithHttpInfo($serverName, $logName, $lineCount = null, $startOffset = null, $filter = null, $search = null, $regexSearch = null, $head = null, $tail = null)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling getServerLogFileConfig');
        }

        // verify the required parameter 'logName' is set
        if ($logName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $logName when calling getServerLogFileConfig');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}/logfiles/{logName}";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        // query params
        if ($lineCount !== null) {
            $queryParams['lineCount'] = $this->apiClient->getSerializer()->toQueryValue($lineCount);
        }// query params
        if ($startOffset !== null) {
            $queryParams['startOffset'] = $this->apiClient->getSerializer()->toQueryValue($startOffset);
        }// query params
        if ($filter !== null) {
            $queryParams['filter'] = $this->apiClient->getSerializer()->toQueryValue($filter);
        }// query params
        if ($search !== null) {
            $queryParams['search'] = $this->apiClient->getSerializer()->toQueryValue($search);
        }// query params
        if ($regexSearch !== null) {
            $queryParams['regexSearch'] = $this->apiClient->getSerializer()->toQueryValue($regexSearch);
        }// query params
        if ($head !== null) {
            $queryParams['head'] = $this->apiClient->getSerializer()->toQueryValue($head);
        }// query params
        if ($tail !== null) {
            $queryParams['tail'] = $this->apiClient->getSerializer()->toQueryValue($tail);
        }
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }// path params
        if ($logName !== null) {
            $resourcePath = str_replace(
                "{" . "logName" . "}",
                $this->apiClient->getSerializer()->toPathValue($logName),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                ServerLogFileConfig::class
            );
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array($this->apiClient->getSerializer()->deserialize($response, ServerLogFileConfig::class, $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), ServerLogFileConfig::class, $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
    /**
     * Operation getServerLogFileDownloadConfig
     *
     * Retrieves the Server Log file for the specified log name, zipped.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $logName The name of the log (required)
     *
     * @return  ServerLogFileDownloadConfig
     * @throws ApiException on non-2xx response
     */
    public function getServerLogFileDownloadConfig($serverName, $logName)
    {
        list($response) = $this->getServerLogFileDownloadConfigWithHttpInfo($serverName, $logName);
        return $response;
    }


    /**
     * Operation getServerLogFileDownloadConfigWithHttpInfo
     *
     * Retrieves the Server Log file for the specified log name, zipped.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $logName The name of the log (required)
     *
     * @return Array of \Model\ServerLogFileDownloadConfig, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function getServerLogFileDownloadConfigWithHttpInfo($serverName, $logName)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling getServerLogFileDownloadConfig');
        }

        // verify the required parameter 'logName' is set
        if ($logName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $logName when calling getServerLogFileDownloadConfig');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}/logfiles/{logName}/download";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }// path params
        if ($logName !== null) {
            $resourcePath = str_replace(
                "{" . "logName" . "}",
                $this->apiClient->getSerializer()->toPathValue($logName),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                ServerLogFileDownloadConfig::class
            );
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array($this->apiClient->getSerializer()->deserialize($response, ServerLogFileDownloadConfig::class, $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), ServerLogFileDownloadConfig::class, $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
    /**
     * Operation getServerLogFilesConfig
     *
     * Retrieves the list of server log files.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $order The order of files in serverLogs list (optional, default to newestFirst)
     *
     * @return  ServerLogFilesConfig
     * @throws ApiException on non-2xx response
     */
    public function getServerLogFilesConfig($serverName, $order = null)
    {
        list($response) = $this->getServerLogFilesConfigWithHttpInfo($serverName, $order);
        return $response;
    }


    /**
     * Operation getServerLogFilesConfigWithHttpInfo
     *
     * Retrieves the list of server log files.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $order The order of files in serverLogs list (optional, default to newestFirst)
     *
     * @return Array of \Model\ServerLogFilesConfig, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function getServerLogFilesConfigWithHttpInfo($serverName, $order = null)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling getServerLogFilesConfig');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}/logfiles";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        // query params
        if ($order !== null) {
            $queryParams['order'] = $this->apiClient->getSerializer()->toQueryValue($order);
        }
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                ServerLogFilesConfig::class
            );
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array($this->apiClient->getSerializer()->deserialize($response, ServerLogFilesConfig::class, $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), ServerLogFilesConfig::class, $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
    /**
     * Operation getServerLogTypesConfig
     *
     * Retrieves the list of available server Log Types.
     *
     * @param string $serverName Reserved for future use (required)
     *
     * @return  ServerLogTypesConfig
     * @throws ApiException on non-2xx response
     */
    public function getServerLogTypesConfig($serverName)
    {
        list($response) = $this->getServerLogTypesConfigWithHttpInfo($serverName);
        return $response;
    }


    /**
     * Operation getServerLogTypesConfigWithHttpInfo
     *
     * Retrieves the list of available server Log Types.
     *
     * @param string $serverName Reserved for future use (required)
     *
     * @return Array of \Model\ServerLogTypesConfig, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function getServerLogTypesConfigWithHttpInfo($serverName)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling getServerLogTypesConfig');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}/logs";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                ServerLogTypesConfig::class
            );
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array($this->apiClient->getSerializer()->deserialize($response, ServerLogTypesConfig::class, $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), ServerLogTypesConfig::class, $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
    /**
     * Operation getServerLogsConfig
     *
     * Retrieves the contents of multiple Server Logs with the specified type in the log name.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $logType The type of the log (required)
     * @param string $lineCount The number of log lines requested, where a postive number indicates log lines after startOffset and a negative number indicate log lines before startOffset (optional, default to 100)
     * @param string $startOffset The byte offset in the file at which to begin getting log lines (optional)
     * @param string $filter A string containing a list of predefined search filters separated by | where valid strings are noDebug,noInfo,noWarn,noError,noHeader,noColumnHeadings (optional)
     * @param string $search A string containing a literal string on which to filter or a regex (optional)
     * @param string $regexSearch Indicates if the &#39;search&#39; parameter is a regex or a literal string (optional, default to false)
     * @param string $head Returns the first x lines from the requested log file, the overrides the startoffset and linecount values (optional)
     * @param string $tail Returns the last x lines from the requested log file, the overrides the startoffset and linecount values (optional)
     * @param string $startDate The start date to filter on (UTC milliseconds) (optional)
     * @param string $endDate The end date to filter on (UTC milliseconds) (optional)
     *
     * @return  ServerLogsConfig
     * @throws ApiException on non-2xx response
     */
    public function getServerLogsConfig($serverName, $logType, $lineCount = null, $startOffset = null, $filter = null, $search = null, $regexSearch = null, $head = null, $tail = null, $startDate = null, $endDate = null)
    {
        list($response) = $this->getServerLogsConfigWithHttpInfo($serverName, $logType, $lineCount, $startOffset, $filter, $search, $regexSearch, $head, $tail, $startDate, $endDate);
        return $response;
    }


    /**
     * Operation getServerLogsConfigWithHttpInfo
     *
     * Retrieves the contents of multiple Server Logs with the specified type in the log name.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $logType The type of the log (required)
     * @param string $lineCount The number of log lines requested, where a postive number indicates log lines after startOffset and a negative number indicate log lines before startOffset (optional, default to 100)
     * @param string $startOffset The byte offset in the file at which to begin getting log lines (optional)
     * @param string $filter A string containing a list of predefined search filters separated by | where valid strings are noDebug,noInfo,noWarn,noError,noHeader,noColumnHeadings (optional)
     * @param string $search A string containing a literal string on which to filter or a regex (optional)
     * @param string $regexSearch Indicates if the &#39;search&#39; parameter is a regex or a literal string (optional, default to false)
     * @param string $head Returns the first x lines from the requested log file, the overrides the startoffset and linecount values (optional)
     * @param string $tail Returns the last x lines from the requested log file, the overrides the startoffset and linecount values (optional)
     * @param string $startDate The start date to filter on (UTC milliseconds) (optional)
     * @param string $endDate The end date to filter on (UTC milliseconds) (optional)
     *
     * @return Array of \Model\ServerLogsConfig, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function getServerLogsConfigWithHttpInfo($serverName, $logType, $lineCount = null, $startOffset = null, $filter = null, $search = null, $regexSearch = null, $head = null, $tail = null, $startDate = null, $endDate = null)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling getServerLogsConfig');
        }

        // verify the required parameter 'logType' is set
        if ($logType === null) {
            throw new \InvalidArgumentException('Missing the required parameter $logType when calling getServerLogsConfig');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}/logs/{logType}";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        // query params
        if ($lineCount !== null) {
            $queryParams['lineCount'] = $this->apiClient->getSerializer()->toQueryValue($lineCount);
        }// query params
        if ($startOffset !== null) {
            $queryParams['startOffset'] = $this->apiClient->getSerializer()->toQueryValue($startOffset);
        }// query params
        if ($filter !== null) {
            $queryParams['filter'] = $this->apiClient->getSerializer()->toQueryValue($filter);
        }// query params
        if ($search !== null) {
            $queryParams['search'] = $this->apiClient->getSerializer()->toQueryValue($search);
        }// query params
        if ($regexSearch !== null) {
            $queryParams['regexSearch'] = $this->apiClient->getSerializer()->toQueryValue($regexSearch);
        }// query params
        if ($head !== null) {
            $queryParams['head'] = $this->apiClient->getSerializer()->toQueryValue($head);
        }// query params
        if ($tail !== null) {
            $queryParams['tail'] = $this->apiClient->getSerializer()->toQueryValue($tail);
        }// query params
        if ($startDate !== null) {
            $queryParams['startDate'] = $this->apiClient->getSerializer()->toQueryValue($startDate);
        }// query params
        if ($endDate !== null) {
            $queryParams['endDate'] = $this->apiClient->getSerializer()->toQueryValue($endDate);
        }
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }// path params
        if ($logType !== null) {
            $resourcePath = str_replace(
                "{" . "logType" . "}",
                $this->apiClient->getSerializer()->toPathValue($logType),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                ServerLogsConfig::class
            );
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array($this->apiClient->getSerializer()->deserialize($response, ServerLogsConfig::class, $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), ServerLogsConfig::class, $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
    /**
     * Operation getServersConfig
     *
     * Retrieves the list of Servers.
     *
     *
     * @return  ServersConfig
     * @throws ApiException on non-2xx response
     */
    public function getServersConfig()
    {
        list($response) = $this->getServersConfigWithHttpInfo();
        return $response;
    }


    /**
     * Operation getServersConfigWithHttpInfo
     *
     * Retrieves the list of Servers.
     *
     *
     * @return Array of \Model\ServersConfig, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function getServersConfigWithHttpInfo()
    {
        
        // parse inputs
        $resourcePath = "/v2/servers";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        
        
        
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                ServersConfig::class
            );
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array($this->apiClient->getSerializer()->deserialize($response, ServersConfig::class, $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), ServersConfig::class, $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
    /**
     * Operation getSourceDriverNamesList
     *
     * Get the list of source control drivers.
     *
     * @param string $serverName Reserved for future use (required)
     *
     * @return  SourceDriverNamesList
     * @throws ApiException on non-2xx response
     */
    public function getSourceDriverNamesList($serverName)
    {
        list($response) = $this->getSourceDriverNamesListWithHttpInfo($serverName);
        return $response;
    }


    /**
     * Operation getSourceDriverNamesListWithHttpInfo
     *
     * Get the list of source control drivers.
     *
     * @param string $serverName Reserved for future use (required)
     *
     * @return Array of \Model\SourceDriverNamesList, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function getSourceDriverNamesListWithHttpInfo($serverName)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling getSourceDriverNamesList');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}/sourcecontrol/drivernames";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                SourceDriverNamesList::class
            );
            if (!$response) {
                return array(null, $statusCode, $httpHeader);
            }

            return array($this->apiClient->getSerializer()->deserialize($response, SourceDriverNamesList::class, $httpHeader), $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), SourceDriverNamesList::class, $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
    /**
     * Operation putServerAction
     *
     * Tells the Server to perform an action.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $action The action which should be performed by the server (required)
     *
     * @return void
     * @throws ApiException on non-2xx response
     */
    public function putServerAction($serverName, $action)
    {
        list($response) = $this->putServerActionWithHttpInfo($serverName, $action);
        return $response;
    }


    /**
     * Operation putServerActionWithHttpInfo
     *
     * Tells the Server to perform an action.
     *
     * @param string $serverName Reserved for future use (required)
     * @param string $action The action which should be performed by the server (required)
     *
     * @return Array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function putServerActionWithHttpInfo($serverName, $action)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling putServerAction');
        }

        // verify the required parameter 'action' is set
        if ($action === null) {
            throw new \InvalidArgumentException('Missing the required parameter $action when calling putServerAction');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}/actions/{action}";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }// path params
        if ($action !== null) {
            $resourcePath = str_replace(
                "{" . "action" . "}",
                $this->apiClient->getSerializer()->toPathValue($action),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams
            );
            return array(null, $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }
    /**
     * Operation putServerConfig
     *
     * Updates the Server configuration.
     *
     * @param string $serverName Reserved for future use (required)
     * @param ServerConfig $body  (required)
     *
     * @return void
     * @throws ApiException on non-2xx response
     */
    public function putServerConfig($serverName, $body)
    {
        list($response) = $this->putServerConfigWithHttpInfo($serverName, $body);
        return $response;
    }


    /**
     * Operation putServerConfigWithHttpInfo
     *
     * Updates the Server configuration.
     *
     * @param string $serverName Reserved for future use (required)
     * @param ServerConfig $body  (required)
     *
     * @return Array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function putServerConfigWithHttpInfo($serverName, $body)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling putServerConfig');
        }

        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling putServerConfig');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams
            );
            return array(null, $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }
    /**
     * Operation putServerConfigAdv
     *
     * Updates the advanced Server configuration.
     *
     * @param string $serverName Reserved for future use (required)
     * @param ServerConfigAdv $body  (required)
     *
     * @return void
     * @throws ApiException on non-2xx response
     */
    public function putServerConfigAdv($serverName, $body)
    {
        list($response) = $this->putServerConfigAdvWithHttpInfo($serverName, $body);
        return $response;
    }


    /**
     * Operation putServerConfigAdvWithHttpInfo
     *
     * Updates the advanced Server configuration.
     *
     * @param string $serverName Reserved for future use (required)
     * @param ServerConfigAdv $body  (required)
     *
     * @return Array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     */
    public function putServerConfigAdvWithHttpInfo($serverName, $body)
    {
        
        // verify the required parameter 'serverName' is set
        if ($serverName === null) {
            throw new \InvalidArgumentException('Missing the required parameter $serverName when calling putServerConfigAdv');
        }

        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException('Missing the required parameter $body when calling putServerConfigAdv');
        }

        // parse inputs
        $resourcePath = "/v2/servers/{serverName}/adv";
        $httpBody = '';
        $queryParams = array();
        $headerParams = array();
        $formParams = array();
        $_header_accept = $this->apiClient->selectHeaderAccept(array('application/xml', 'text/xml', 'application/json'));
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(array('application/xml','text/xml','application/json'));

        
        
        // path params
        if ($serverName !== null) {
            $resourcePath = str_replace(
                "{" . "serverName" . "}",
                $this->apiClient->getSerializer()->toPathValue($serverName),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
                // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams
            );
            return array(null, $statusCode, $httpHeader);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }
}
